
| #   | Question                                                                                       | Answer                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Edge Cases                                                                                                                                                                                |
| --- | ---------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1   | What is the difference between `var`, `let`, and `const` in JavaScript?                        | `var` is function-scoped and can be redeclared, leading to hoisting issues. `let` is block-scoped, reassignable, but not redeclarable in the same scope. `const` is block-scoped, cannot be redeclared or reassigned, but objects/arrays declared with `const` can have their properties/elements mutated.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Edge cases: `var` hoisting can cause unexpected behavior if variables are accessed before declaration. `const` with objects can confuse beginners since properties can still be modified. |
| 2   | Explain how `this` keyword works in JavaScript.                                                | `this` refers to the object executing the current function. In global scope, `this` is the `window` (browser) or `global` (Node.js). In methods, `this` is the object owning the method. In arrow functions, `this` is lexically bound to the enclosing scope.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Edge cases: `this` in event handlers defaults to the DOM element. Using `call`, `apply`, or `bind` can override `this`. Strict mode changes `this` in global functions to `undefined`.    |
| 3   | What is closure in JavaScript? Provide an example.                                             | A closure is a function that retains access to its lexical scope's variables even after the outer function has finished executing. Example: `javascript function outer() { let count = 0; return function inner() { return count++; } } const counter = outer(); console.log(counter()); // 0 console.log(counter()); // 1`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Edge cases: Closures can lead to memory leaks if variables are unintentionally retained. Multiple closures sharing the same outer scope can interfere with each other.                    |
| 4   | How does event delegation work in JavaScript?                                                  | Event delegation uses event bubbling to handle events at a higher level in the DOM. Instead of attaching listeners to individual elements, you attach one to a parent, checking the `event.target` to handle specific elements. Example: `javascript document.querySelector('#list').addEventListener('click', (e) => { if (e.target.tagName === 'LI') { console.log(e.target.textContent); } });`                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Edge cases: Events that don’t bubble (e.g., `focus`) can’t be delegated. Improper `event.target` checks may cause errors with nested elements.                                            |
| 5   | What is the difference between `==` and `===` in JavaScript?                                   | `==` performs type coercion before comparison, while `===` checks both value and type without coercion. Example: `javascript console.log(5 == '5'); // true console.log(5 === '5'); // false`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Edge cases: `null == undefined` is `true`, but `null === undefined` is `false`. Objects with `==` may coerce to primitives unexpectedly.                                                  |
| 6   | Explain the event loop in JavaScript.                                                          | The event loop manages asynchronous operations in JavaScript’s single-threaded model. It processes the call stack, then the task queue (macrotasks like `setTimeout`) and microtask queue (e.g., `Promise` callbacks). Microtasks have higher priority. Example: `javascript console.log('Start'); setTimeout(() => console.log('Timeout'), 0); Promise.resolve().then(() => console.log('Promise')); console.log('End'); // Output: Start, End, Promise, Timeout`                                                                                                                                                                                                                                                                                                                                                                                               | Edge cases: Heavy synchronous code can block the event loop, delaying async tasks. Microtask overflow can starve macrotasks.                                                              |
| 7   | What is the purpose of `Array.prototype.map`? Provide an example.                              | `map` creates a new array by applying a function to each element of the original array. It doesn’t mutate the original. Example: `javascript const numbers = [1, 2, 3]; const doubled = numbers.map(n => n * 2); console.log(doubled); // [2, 4, 6]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Edge cases: Returning `undefined` in the callback can lead to an array of `undefined` values. Sparse arrays may skip empty slots.                                                         |
| 8   | How does prototypal inheritance work in JavaScript?                                            | JavaScript uses prototypes for inheritance. Objects inherit properties and methods from their prototype via the `[[Prototype]]` chain. Example: `javascript function Animal(name) { this.name = name; } Animal.prototype.speak = function() { console.log(`${[this.name](http://this.name)} speaks`); }; const dog = new Animal('Dog'); dog.speak(); // Dog speaks`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Edge cases: Modifying a prototype affects all instances. `Object.create(null)` creates an object with no prototype.                                                                       |
| 9   | What is the difference between `null` and `undefined`?                                         | `undefined` means a variable has been declared but not assigned a value. `null` is an explicit assignment of no value. Example: `javascript let a; console.log(a); // undefined console.log(typeof null); // object (historical bug)`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Edge cases: `typeof null` returns `object`. `null == undefined` is `true`, but `null === undefined` is `false`.                                                                           |
| 10  | Explain `async` and `await` in JavaScript.                                                     | `async` declares a function that returns a `Promise`. `await` pauses execution until the `Promise` resolves. Example: `javascript async function fetchData() { const res = await fetch('<https://api.example.com/data>'); return res.json(); }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Edge cases: `await` only works inside `async` functions. Unhandled promise rejections can cause errors. Blocking code with `await` can affect performance.                                |
| 11  | What is the purpose of `Array.prototype.filter`? Provide an example.                           | `filter` creates a new array with elements that pass a test provided by a callback function. Example: `javascript const numbers = [1, 2, 3, 4]; const evens = numbers.filter(n => n % 2 === 0); console.log(evens); // [2, 4]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Edge cases: Returning non-boolean values in the callback can coerce to `true`/`false`. Sparse arrays skip empty slots.                                                                    |
| 12  | What is hoisting in JavaScript?                                                                | Hoisting is JavaScript’s behavior of moving declarations (not initializations) to the top of their scope. Example: `javascript console.log(x); // undefined var x = 5;` Function declarations are fully hoisted, unlike `let`/`const`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Edge cases: `let`/`const` declarations are hoisted but not initialized, causing a Temporal Dead Zone (TDZ) error if accessed before declaration.                                          |
| 13  | How do you deep clone an object in JavaScript?                                                 | Use `structuredClone` (modern browsers) or `JSON.parse(JSON.stringify(obj))` for simple objects. For complex cases (e.g., functions, circular refs), use a recursive function. Example: ```javascript function deepClone(obj) { if (obj === null                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                           |
| 14  | What is the difference between `call`, `apply`, and `bind`?                                    | `call` and `apply` invoke a function with a specified `this` context; `call` takes arguments individually, `apply` takes an array. `bind` returns a new function with a fixed `this`. Example: `javascript function greet(greeting) { console.log(`${greeting}, ${[this.name](http://this.name)}`); } const obj = { name: 'Alice' }; greet.call(obj, 'Hello'); // Hello, Alice greet.apply(obj, ['Hi']); // Hi, Alice const bound = greet.bind(obj); bound('Hey'); // Hey, Alice`                                                                                                                                                                                                                                                                                                                                                                                | Edge cases: Passing `null` as `this` defaults to `window` in non-strict mode. `apply` with large arrays can hit call stack limits.                                                        |
| 15  | Explain the concept of currying in JavaScript.                                                 | Currying transforms a function with multiple arguments into a sequence of single-argument functions. Example: `javascript function curry(fn) { return function curried(...args) { return args.length >= fn.length ? fn(...args) : (...nextArgs) => curried(...args, ...nextArgs); }; } const add = curry((a, b, c) => a + b + c); console.log(add(1)(2)(3)); // 6`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Edge cases: Incorrect argument handling can lead to unexpected results. Curried functions may confuse beginners.                                                                          |
| 16  | What is the purpose of `Array.prototype.reduce`? Provide an example.                           | `reduce` applies a function against an accumulator and each element to reduce the array to a single value. Example: `javascript const numbers = [1, 2, 3, 4]; const sum = numbers.reduce((acc, curr) => acc + curr, 0); console.log(sum); // 10`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Edge cases: No initial value with an empty array throws an error. Non-numeric operations may lead to type coercion issues.                                                                |
| 17  | How does JavaScript handle type coercion?                                                      | JavaScript automatically converts types during operations (e.g., `+` with strings). Example: `javascript console.log(1 + '2'); // '12' console.log(1 - '2'); // -1` Coercion follows rules like converting to primitives via `toString` or `valueOf`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Edge cases: `[] + {}` results in `[object Object]`. `null + 1` coerces `null` to `0`.                                                                                                     |
| 18  | What is a Promise in JavaScript? Provide an example.                                           | A `Promise` represents a value that may be available now, later, or never. It has states: `pending`, `fulfilled`, or `rejected`. Example: `javascript const promise = new Promise((resolve, reject) => { setTimeout(() => resolve('Done'), 1000); }); promise.then(result => console.log(result)); // Done`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Edge cases: Unhandled rejections can cause warnings. Chaining without returning in `.then` breaks the chain.                                                                              |
| 19  | What is the difference between `forEach` and `map`?                                            | `forEach` executes a function for each array element but returns `undefined`. `map` creates a new array with the results of the function. Example: `javascript const arr = [1, 2, 3]; arr.forEach(x => console.log(x)); // Logs 1, 2, 3 const doubled = arr.map(x => x * 2); // [2, 4, 6]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Edge cases: `forEach` mutating the array can cause issues. `map` with no return value results in `undefined` elements.                                                                    |
| 20  | Explain the concept of debouncing in JavaScript.                                               | Debouncing delays a function’s execution until after a specified wait time since the last call. Useful for rate-limiting. Example: `javascript function debounce(fn, wait) { let timeout; return function(...args) { clearTimeout(timeout); timeout = setTimeout(() => fn(...args), wait); }; } const log = debounce(() => console.log('Called'), 1000);`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Edge cases: Rapid calls may never execute if the wait time isn’t reached. Memory leaks if `clearTimeout` is omitted.                                                                      |
| 21  | What is the purpose of `Object.create`? Provide an example.                                    | `Object.create` creates a new object with the specified prototype. Example: `javascript const proto = { greet() { console.log('Hello'); } }; const obj = Object.create(proto); obj.greet(); // Hello`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Edge cases: Passing `null` creates an object with no prototype. Property descriptors can lead to unexpected behavior if misused.                                                          |
| 22  | How does `setTimeout` work with a delay of 0?                                                  | `setTimeout(fn, 0)` schedules the function to run after the current call stack clears, in the next event loop iteration. Example: `javascript console.log('Start'); setTimeout(() => console.log('Timeout'), 0); console.log('End'); // Start, End, Timeout`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Edge cases: Heavy synchronous code can delay execution. Microtasks (e.g., Promises) run before `setTimeout(0)`.                                                                           |
| 23  | What is the difference between `slice` and `splice`?                                           | `slice` returns a shallow copy of a portion of an array without modifying the original. `splice` modifies the array by removing/adding elements and returns the removed elements. Example: `javascript const arr = [1, 2, 3, 4]; console.log(arr.slice(1, 3)); // [2, 3] console.log(arr.splice(1, 2)); // [2, 3] console.log(arr); // [1, 4]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Edge cases: Negative indices in `slice`. `splice` with invalid indices can cause errors.                                                                                                  |
| 24  | Explain the concept of memoization in JavaScript.                                              | Memoization caches function results to avoid redundant computations. Example: `javascript function memoize(fn) { const cache = new Map(); return function(...args) { const key = JSON.stringify(args); if (cache.has(key)) return cache.get(key); const result = fn(...args); cache.set(key, result); return result; }; } const factorial = memoize(n => n === 0 ? 1 : n * factorial(n - 1));`                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Edge cases: Cache growth can lead to memory issues. Non-serializable arguments break `JSON.stringify`.                                                                                    |
| 25  | What is the difference between `Object.keys` and `for...in`?                                   | `Object.keys` returns an array of an object’s own enumerable property names. `for...in` iterates over enumerable properties, including inherited ones. Example: `javascript const obj = { a: 1 }; Object.setPrototypeOf(obj, { b: 2 }); console.log(Object.keys(obj)); // ['a'] for (let key in obj) console.log(key); // a, b`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Edge cases: `for...in` includes inherited properties, which may be unexpected. Non-enumerable properties are skipped.                                                                     |
| 26  | How do you handle errors in Promises?                                                          | Use `.catch` for rejections and `try/catch` with `async/await`. Example: `javascript async function example() { try { const res = await Promise.reject('Error'); } catch (err) { console.log(err); // Error } }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Edge cases: Unhandled rejections in Promises can cause warnings. Mixing `then` and `await` can lead to confusion.                                                                         |
| 27  | What is the purpose of `Array.prototype.some`? Provide an example.                             | `some` tests if at least one element passes the callback test, returning a boolean. Example: `javascript const arr = [1, 2, 3]; console.log(arr.some(x => x > 2)); // true`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Edge cases: Empty arrays return `false`. Non-boolean callback results are coerced.                                                                                                        |
| 28  | Explain the concept of throttling in JavaScript.                                               | Throttling limits a function’s execution rate, ensuring it runs at most once per specified interval. Example: `javascript function throttle(fn, wait) { let lastCall = 0; return function(...args) { const now = Date.now(); if (now - lastCall >= wait) { fn(...args); lastCall = now; } }; } const log = throttle(() => console.log('Called'), 1000);`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Edge cases: Trailing calls may be ignored. High-frequency events can queue up unnecessarily.                                                                                              |
| 29  | What is the difference between `Object.assign` and spread operator?                            | `Object.assign` copies enumerable own properties to a target object. The spread operator (`...`) creates a shallow copy or merges objects. Example: `javascript const obj1 = { a: 1 }; const obj2 = { b: 2 }; const merged = Object.assign({}, obj1, obj2); // { a: 1, b: 2 } const spread = { ...obj1, ...obj2 }; // { a: 1, b: 2 }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Edge cases: `Object.assign` mutates the target. Spread doesn’t handle non-enumerable properties or prototypes.                                                                            |
| 30  | How does `try/catch` work in JavaScript?                                                       | `try/catch` handles synchronous errors. The `try` block runs code, and if an error occurs, the `catch` block handles it. Example: `javascript try { throw new Error('Test'); } catch (err) { console.log(err.message); // Test }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Edge cases: Async errors (e.g., in Promises) require `.catch`. `finally` runs regardless of errors.                                                                                       |
| 31  | What is the purpose of `Array.prototype.every`? Provide an example.                            | `every` tests if all elements pass the callback test, returning a boolean. Example: `javascript const arr = [1, 2, 3]; console.log(arr.every(x => x > 0)); // true`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Edge cases: Empty arrays return `true`. Non-boolean callback results are coerced.                                                                                                         |
| 32  | Explain the concept of a higher-order function in JavaScript.                                  | A higher-order function takes a function as an argument or returns a function. Example: `javascript function higher(fn) { return function(...args) { console.log('Before'); fn(...args); console.log('After'); }; } const say = higher((msg) => console.log(msg)); say('Hello'); // Before, Hello, After`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Edge cases: Improper function arguments can lead to errors. Closures in returned functions may retain unintended variables.                                                               |
| 33  | What is the difference between `setInterval` and `setTimeout`?                                 | `setTimeout` executes a function once after a delay. `setInterval` repeatedly executes a function at a fixed interval. Example: `javascript setTimeout(() => console.log('Once'), 1000); setInterval(() => console.log('Repeat'), 1000);`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Edge cases: `setInterval` can queue multiple calls if the function takes longer than the interval. Forgetting to clear intervals causes memory leaks.                                     |
| 34  | How do you check if a variable is an array in JavaScript?                                      | Use `Array.isArray()`. Example: `javascript console.log(Array.isArray([1, 2, 3])); // true console.log(Array.isArray({})); // false`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Edge cases: Objects with `length` property can mimic arrays. Older methods like `instanceof Array` fail across iframes.                                                                   |
| 35  | What is the purpose of `Object.defineProperty`? Provide an example.                            | `Object.defineProperty` defines a new property or modifies an existing one with specific attributes (e.g., writable, enumerable). Example: `javascript const obj = {}; Object.defineProperty(obj, 'prop', { value: 42, writable: false }); console.log(obj.prop); // 42 obj.prop = 100; console.log(obj.prop); // 42`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Edge cases: Non-writable properties can’t be changed. Non-enumerable properties are skipped by `for...in`.                                                                                |
| 36  | Explain the concept of promises chaining.                                                      | Promise chaining allows sequential asynchronous operations using `.then`. Example: `javascript Promise.resolve(1) .then(x => x + 1) .then(x => x * 2) .then(console.log); // 4`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Edge cases: Forgetting to return in `.then` breaks the chain. Errors in one `.then` skip to the next `.catch`.                                                                            |
| 37  | What is the difference between shallow and deep copying?                                       | Shallow copying copies references to nested objects, while deep copying creates new copies of all nested objects. Example: `javascript const obj = { a: { b: 1 } }; const shallow = { ...obj }; const deep = JSON.parse(JSON.stringify(obj)); shallow.a.b = 2; console.log(obj.a.b); // 2 (shallow affects original) deep.a.b = 3; console.log(obj.a.b); // 2`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Edge cases: `JSON.stringify` fails with circular references or functions. Shallow copying affects nested objects.                                                                         |
| 38  | How does `Array.prototype.includes` work? Provide an example.                                  | `includes` checks if an array contains a specific value, returning a boolean. Example: `javascript const arr = [1, 2, 3]; console.log(arr.includes(2)); // true`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Edge cases: `includes` uses strict equality (`===`). For objects, it checks reference, not deep equality.                                                                                 |
| 39  | What is the purpose of `Object.freeze`? Provide an example.                                    | `Object.freeze` prevents modification of an object’s properties (shallow freeze). Example: `javascript const obj = Object.freeze({ a: 1 }); obj.a = 2; console.log(obj.a); // 1`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Edge cases: Nested objects are not frozen. Strict mode throws errors on attempted modifications.                                                                                          |
| 40  | Explain the concept of a generator function in JavaScript.                                     | Generator functions (`function*`) yield values one at a time, pausing execution. Example: `javascript function* generator() { yield 1; yield 2; yield 3; } const gen = generator(); console.log(gen.next().value); // 1 console.log(gen.next().value); // 2`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Edge cases: Calling `next()` after `done: true` returns `undefined`. Generators can cause memory issues if not properly managed.                                                          |
| 41  | What is the difference between `null`, `undefined`, and `NaN`?                                 | `null` is an explicit absence of value. `undefined` is a variable with no assigned value. `NaN` is a non-numeric value from invalid math operations. Example: `javascript console.log(typeof null); // object console.log(typeof undefined); // undefined console.log(Number.isNaN(NaN)); // true`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Edge cases: `NaN !== NaN`. `null == undefined` is `true`, but `null === undefined` is `false`.                                                                                            |
| 42  | How do you handle asynchronous errors in JavaScript?                                           | Use `try/catch` for `async/await` and `.catch` for Promises. Example: `javascript async function example() { try { await Promise.reject('Error'); } catch (err) { console.log(err); } }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Edge cases: Unhandled promise rejections can cause warnings. Mixing sync and async error handling can lead to missed errors.                                                              |
| 43  | What is the purpose of `Array.prototype.find`? Provide an example.                             | `find` returns the first element that satisfies the callback. Example: `javascript const arr = [1, 2, 3]; console.log(arr.find(x => x > 1)); // 2`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Edge cases: Returns `undefined` if no element is found. Non-boolean callback results are coerced.                                                                                         |
| 44  | Explain the concept of a WeakMap in JavaScript.                                                | `WeakMap` is a collection of key-value pairs where keys are objects and values can be anything. Keys are weakly referenced, allowing garbage collection. Example: `javascript const wm = new WeakMap(); const obj = {}; wm.set(obj, 'value'); console.log(wm.get(obj)); // value`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Edge cases: `WeakMap` keys must be objects. No iteration or size property due to weak references.                                                                                         |
| 45  | What is the difference between `let` and `const` in a `for` loop?                              | `let` allows reassignment in a loop, creating a new binding per iteration. `const` prevents reassignment but still creates a new binding per iteration. Example: `javascript for (let i = 0; i < 3; i++) { setTimeout(() => console.log(i), 0); } // 0, 1, 2 for (const i = 0; i < 3; i++) {} // Error: i is not reassignable`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Edge cases: `const` in a `for...of` loop works since it’s a new binding each iteration. `var` causes issues in async loops due to hoisting.                                               |
| 46  | How does `Array.prototype.sort` work? Provide an example.                                      | `sort` modifies the array in place, sorting elements based on a comparison function. Example: `javascript const arr = [3, 1, 2]; arr.sort((a, b) => a - b); console.log(arr); // [1, 2, 3]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Edge cases: Without a comparison function, sorts as strings (`[10, 2]` becomes `[10, 2]`). Non-numeric sorting requires custom logic.                                                     |
| 47  | What is the purpose of `Object.seal`? Provide an example.                                      | `Object.seal` prevents adding or removing properties but allows modifying existing ones. Example: `javascript const obj = Object.seal({ a: 1 }); obj.b = 2; // Ignored obj.a = 3; console.log(obj); // { a: 3 }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Edge cases: Nested objects are not sealed. Strict mode throws errors on attempted additions.                                                                                              |
| 48  | Explain the concept of a Proxy in JavaScript.                                                  | A `Proxy` wraps an object to intercept and customize operations (e.g., property access). Example: ```javascript const target = { a: 1 }; const proxy = new Proxy(target, { get: (obj, prop) => obj[prop]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                           |
| 49  | What is the difference between `Map` and `Object`?                                             | `Map` is a key-value collection with any key type, maintaining insertion order. `Object` uses strings/symbols as keys and has prototype inheritance. Example: `javascript const map = new Map([[1, 'one']]); console.log(map.get(1)); // one`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Edge cases: `Map` preserves non-string keys. `Object` may have prototype conflicts with keys like `__proto__`.                                                                            |
| 50  | How do you implement a custom iterator in JavaScript?                                          | Use the `[Symbol.iterator]` method to define iteration behavior. Example: `javascript const myIterable = { items: [1, 2, 3], [Symbol.iterator]() { let i = 0; return { next: () => i < this.items.length ? { value: this.items[i++], done: false } : { done: true } }; } }; for (let x of myIterable) console.log(x); // 1, 2, 3`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Edge cases: Incorrect `next` implementation can cause infinite loops. Missing `done: true` breaks iteration.                                                                              |
| 51  | What is the purpose of `Promise.all`? Provide an example.                                      | `Promise.all` takes an array of Promises and resolves when all resolve or rejects on the first rejection. Example: `javascript Promise.all([Promise.resolve(1), Promise.resolve(2)]).then(values => console.log(values)); // [1, 2]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Edge cases: Empty array resolves immediately. A single rejection halts the process.                                                                                                       |
| 52  | Explain the concept of a Symbol in JavaScript.                                                 | `Symbol` creates unique, immutable identifiers, often used as object keys to avoid conflicts. Example: `javascript const sym = Symbol('id'); const obj = { [sym]: 123 }; console.log(obj[sym]); // 123`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Edge cases: Symbols are not enumerable in `for...in`. `Symbol('id') !== Symbol('id')`.                                                                                                    |
| 53  | What is the difference between `Promise.race` and `Promise.any`?                               | `Promise.race` resolves or rejects with the first Promise that settles. `Promise.any` resolves with the first fulfilled Promise, ignoring rejections unless all reject. Example: `javascript Promise.race([Promise.reject('Error'), Promise.resolve(1)]).catch(err => console.log(err)); // Error Promise.any([Promise.reject('Error'), Promise.resolve(1)]).then(val => console.log(val)); // 1`                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Edge cases: `Promise.any` with all rejections returns an `AggregateError`. Empty arrays behave differently.                                                                               |
| 54  | How do you handle circular references in JavaScript objects?                                   | Circular references occur when objects reference each other. Use `WeakMap` or custom serialization. Example: `javascript const obj = {}; obj.self = obj; const cache = new WeakMap(); function serialize(obj) { if (cache.has(obj)) return '[Circular]'; cache.set(obj, true); return JSON.stringify(obj, (k, v) => typeof v === 'object' ? serialize(v) : v); }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Edge cases: `JSON.stringify` throws on circular refs without a replacer. Deep nesting can cause stack overflow.                                                                           |
| 55  | What is the purpose of `Array.prototype.flat`? Provide an example.                             | `flat` flattens nested arrays to a specified depth. Example: `javascript const arr = [1, [2, [3, 4]]]; console.log(arr.flat(1)); // [1, 2, [3, 4]] console.log(arr.flat(Infinity)); // [1, 2, 3, 4]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Edge cases: Non-array elements are unaffected. Large nested arrays may impact performance.                                                                                                |
| 56  | Explain the concept of a WeakSet in JavaScript.                                                | `WeakSet` is a collection of unique objects, with weak references allowing garbage collection. Example: `javascript const ws = new WeakSet(); const obj = {}; ws.add(obj); console.log(ws.has(obj)); // true`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Edge cases: Only objects can be added. No iteration or size due to weak references.                                                                                                       |
| 57  | What is the difference between `Function.prototype.bind` and arrow functions?                  | `bind` creates a new function with a fixed `this`. Arrow functions lexically bind `this` and cannot be rebound. Example: `javascript const obj = { name: 'Alice', greet: function() { console.log(this.name); } }; const bound = obj.greet.bind(obj); bound(); // Alice const arrow = () => console.log(this.name); arrow.bind(obj)(); // undefined (or window.name)`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Edge cases: Arrow functions ignore `call`/`apply`. `bind` creates a new function, increasing memory usage.                                                                                |
| 58  | How do you implement a custom event emitter in JavaScript?                                     | Create a class to manage events and listeners. Example: `javascript class EventEmitter { constructor() { this.events = new Map(); } on(event, listener) { if (!this.events.has(event)) this.events.set(event, []); this.events.get(event).push(listener); } emit(event, ...args) { if (this.events.has(event)) this.events.get(event).forEach(listener => listener(...args)); } } const emitter = new EventEmitter(); emitter.on('greet', name => console.log(`Hello, ${name}`)); emitter.emit('greet', 'Alice'); // Hello, Alice`                                                                                                                                                                                                                                                                                                                               | Edge cases: Unremoved listeners cause memory leaks. Invalid event names can lead to silent failures.                                                                                      |
| 59  | What is the purpose of `Array.prototype.concat`? Provide an example.                           | `concat` creates a new array by combining the original array with other arrays/values. Example: `javascript const arr1 = [1, 2]; const arr2 = [3, 4]; console.log(arr1.concat(arr2, 5)); // [1, 2, 3, 4, 5]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Edge cases: Nested arrays are not flattened. Large concatenations can impact performance.                                                                                                 |
| 60  | Explain the concept of a tagged template literal in JavaScript.                                | Tagged template literals allow a function to process a template string. Example: ```javascript function tag(strings, ...values) { return strings.reduce((acc, str, i) => acc + str + (values[i]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                           |
| 61  | What is the difference between `Object.getOwnPropertyNames` and `Object.keys`?                 | `Object.keys` returns enumerable own property names. `Object.getOwnPropertyNames` returns all own property names, including non-enumerable ones. Example: `javascript const obj = Object.defineProperty({}, 'a', { value: 1, enumerable: false }); console.log(Object.keys(obj)); // [] console.log(Object.getOwnPropertyNames(obj)); // ['a']`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Edge cases: Non-enumerable properties are skipped by `Object.keys`. Symbols are excluded.                                                                                                 |
| 62  | How do you implement a debounce function with immediate execution?                             | Add an option to execute the function immediately on the first call. Example: `javascript function debounce(fn, wait, immediate = false) { let timeout; return function(...args) { const callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(() => { timeout = null; if (!immediate) fn(...args); }, wait); if (callNow) fn(...args); }; }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Edge cases: Rapid calls with `immediate` can lead to multiple executions. Memory leaks if not cleared properly.                                                                           |
| 63  | What is the purpose of `Promise.allSettled`? Provide an example.                               | `Promise.allSettled` resolves when all Promises settle, returning an array of their outcomes (`{ status, value/reason }`). Example: `javascript Promise.allSettled([Promise.resolve(1), Promise.reject('Error')]).then(results => console.log(results)); // [{ status: 'fulfilled', value: 1 }, { status: 'rejected', reason: 'Error' }]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Edge cases: Always resolves, even with rejections. Empty arrays return an empty array.                                                                                                    |
| 64  | Explain the concept of a Module in JavaScript.                                                 | Modules encapsulate code, exposing only specified exports. Use `import`/`export`. Example: `javascript // math.js export const add = (a, b) => a + b; // main.js import { add } from './math.js'; console.log(add(1, 2)); // 3`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Edge cases: Cyclic dependencies can cause errors. Missing exports lead to `undefined`.                                                                                                    |
| 65  | What is the difference between `Array.prototype.push` and spread operator for adding elements? | `push` mutates the array by adding elements. Spread operator creates a new array. Example: `javascript const arr = [1, 2]; arr.push(3); console.log(arr); // [1, 2, 3] const newArr = [...arr, 4]; console.log(newArr); // [1, 2, 3, 4]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Edge cases: `push` with large arrays can be slower. Spread creates shallow copies, affecting nested objects.                                                                              |
| 66  | How do you implement a throttle function with leading and trailing options?                    | Allow execution at the start (leading) or end (trailing) of the wait period. Example: `javascript function throttle(fn, wait, { leading = true, trailing = true } = {}) { let lastCall = 0, timeout; return function(...args) { const now = Date.now(); if (leading && now - lastCall >= wait) { fn(...args); lastCall = now; } if (trailing) { clearTimeout(timeout); timeout = setTimeout(() => { fn(...args); lastCall = now; }, wait); } }; }`                                                                                                                                                                                                                                                                                                                                                                                                               | Edge cases: Missing `leading`/`trailing` options can lead to no execution. Rapid calls require careful timeout management.                                                                |
| 67  | What is the purpose of `Object.getPrototypeOf`? Provide an example.                            | `Object.getPrototypeOf` returns an object’s prototype. Example: `javascript const obj = {}; console.log(Object.getPrototypeOf(obj) === Object.prototype); // true`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Edge cases: `null` prototype returns `null`. Proxies may require special handling.                                                                                                        |
| 68  | Explain the concept of dynamic import in JavaScript.                                           | Dynamic `import()` loads modules asynchronously, returning a Promise. Example: `javascript async function loadModule() { const module = await import('./math.js'); console.log(module.add(1, 2)); // 3 }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Edge cases: Network failures cause rejections. Dynamic imports don’t work in non-module contexts.                                                                                         |
| 69  | What is the difference between `Array.prototype.join` and `toString`?                          | `join` concatenates array elements with a separator, returning a string. `toString` calls `join` with a comma. Example: `javascript const arr = [1, 2, 3]; console.log(arr.join('-')); // 1-2-3 console.log(arr.toString()); // 1,2,3`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Edge cases: `null`/`undefined` elements coerce to empty strings. Nested arrays are flattened in `toString`.                                                                               |
| 70  | How do you implement a polyfill for `Array.prototype.map`?                                     | Create a custom `map` function. Example: `javascript Array.prototype.myMap = function(callback, thisArg) { const result = []; for (let i = 0; i < this.length; i++) { result.push(callback.call(thisArg, this[i], i, this)); } return result; }; console.log([1, 2, 3].myMap(x => x * 2)); // [2, 4, 6]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Edge cases: Sparse arrays skip empty slots. Incorrect `thisArg` binding can cause errors.                                                                                                 |
| 71  | What is the purpose of `Reflect` in JavaScript? Provide an example.                            | `Reflect` provides methods for interceptable operations, mirroring `Object` methods. Example: `javascript const obj = { a: 1 }; Reflect.set(obj, 'b', 2); console.log(obj); // { a: 1, b: 2 }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Edge cases: `Reflect` methods throw on invalid targets. Proxies often use `Reflect` for default behavior.                                                                                 |
| 72  | Explain the concept of a private class field in JavaScript.                                    | Private fields (using `#`) restrict access to within the class. Example: `javascript class MyClass { #privateField = 42; getField() { return this.#privateField; } } const instance = new MyClass(); console.log(instance.getField()); // 42 console.log(instance.#privateField); // Error`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Edge cases: Accessing private fields outside the class throws a syntax error. Private fields are not inherited.                                                                           |
| 73  | What is the difference between `Array.prototype.at` and array indexing?                        | `at` supports negative indices and is more explicit. Example: `javascript const arr = [1, 2, 3]; console.log(arr.at(-1)); // 3 console.log(arr[arr.length - 1]); // 3`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Edge cases: `at` with invalid indices returns `undefined`. Non-integer indices behave like regular indexing.                                                                              |
| 74  | How do you implement a custom Promise implementation?                                          | Create a class with state management and chaining. Example: ```javascript class MyPromise { constructor(executor) { this.state = 'pending'; this.value = null; this.callbacks = []; executor(this.resolve.bind(this), this.reject.bind(this)); } resolve(value) { if (this.state !== 'pending') return; this.state = 'fulfilled'; this.value = value; this.callbacks.forEach(cb => cb.onFulfilled(value)); } reject(reason) { if (this.state !== 'pending') return; this.state = 'rejected'; this.value = reason; this.callbacks.forEach(cb => cb.onRejected(reason)); } then(onFulfilled, onRejected) { return new MyPromise((resolve, reject) => { const handle = (cb, value) => { try { resolve(cb(value)); } catch (err) { reject(err); } }; this.callbacks.push({ onFulfilled: value => handle(onFulfilled, value), onRejected: reason => handle(onRejected |                                                                                                                                                                                           |
| 75  | What is the purpose of `Array.prototype.flatMap`? Provide an example.                          | `flatMap` maps each element to an array and flattens the result. Example: `javascript const arr = [1, 2, 3]; console.log(arr.flatMap(x => [x, x * 2])); // [1, 2, 2, 4, 3, 6]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Edge cases: Non-array returns are treated as single-element arrays. Large arrays can impact performance.                                                                                  |
| 76  | Explain the concept of a static class method in JavaScript.                                    | Static methods are called on the class, not instances. Example: `javascript class MyClass { static add(a, b) { return a + b; } } console.log(MyClass.add(1, 2)); // 3`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Edge cases: Static methods are not available on instances. Inheritance requires explicit calls.                                                                                           |
| 77  | What is the difference between `Object.create` and `new` operator?                             | `Object.create` creates an object with a specified prototype. `new` creates an instance of a constructor, setting its prototype. Example: `javascript function MyClass() { this.a = 1; } const obj1 = Object.create(MyClass.prototype); const obj2 = new MyClass(); console.log(obj1.a); // undefined console.log(obj2.a); // 1`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Edge cases: `Object.create` doesn’t run the constructor. `new` requires a constructor function.                                                                                           |
| 78  | How do you implement a curry function with placeholder support?                                | Allow placeholders (e.g., `_`) to skip arguments. Example: `javascript const _ = Symbol('placeholder'); function curry(fn, ...args) { return function(...nextArgs) { const combined = args.map(a => a === _ ? nextArgs.shift() : a).concat(nextArgs); return combined.length >= fn.length ? fn(...combined) : curry(fn, ...combined); }; } const add = curry((a, b, c) => a + b + c); console.log(add(1, _, 3)(2)); // 6`                                                                                                                                                                                                                                                                                                                                                                                                                                        | Edge cases: Incorrect placeholder usage can lead to argument mismatches. Large argument lists can cause errors.                                                                           |
| 79  | What is the purpose of `Array.prototype.entries`? Provide an example.                          | `entries` returns an iterator of array entries as `[index, value]` pairs. Example: `javascript const arr = ['a', 'b']; for (const [i, v] of arr.entries()) { console.log(i, v); } // 0 a, 1 b`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Edge cases: Sparse arrays skip empty slots. Iterator must be consumed correctly.                                                                                                          |
| 80  | Explain the concept of a Proxy trap for property deletion.                                     | The `deleteProperty` trap intercepts property deletion. Example: `javascript const target = { a: 1 }; const proxy = new Proxy(target, { deleteProperty(target, prop) { console.log(`Deleting ${prop}`); return Reflect.deleteProperty(target, prop); } }); delete proxy.a; // Deleting a`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Edge cases: Non-configurable properties can’t be deleted. Missing `Reflect.deleteProperty` can cause errors.                                                                              |
| 81  | What is the difference between `Array.prototype.fill` and `Array.prototype.map`?               | `fill` replaces elements with a static value. `map` transforms elements with a function. Example: `javascript const arr = [1, 2, 3]; console.log(arr.fill(0)); // [0, 0, 0] console.log(arr.map(() => 0)); // [0, 0, 0]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Edge cases: `fill` mutates the array. `map` creates a new array but may return `undefined` if the callback doesn’t return.                                                                |
| 82  | How do you implement a custom async iterator?                                                  | Use `[Symbol.asyncIterator]` to define async iteration. Example: `javascript const myAsyncIterable = { async *[Symbol.asyncIterator]() { yield await Promise.resolve(1); yield await Promise.resolve(2); } }; (async () => { for await (const x of myAsyncIterable) console.log(x); })(); // 1, 2`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Edge cases: Errors in async iteration require `try/catch`. Unfinished iterators can cause memory leaks.                                                                                   |
| 83  | What is the purpose of `Object.fromEntries`? Provide an example.                               | `Object.fromEntries` creates an object from an iterable of key-value pairs. Example: `javascript const entries = [['a', 1], ['b', 2]]; console.log(Object.fromEntries(entries)); // { a: 1, b: 2 }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Edge cases: Invalid entries (e.g., non-string keys) may cause errors. Duplicate keys overwrite earlier values.                                                                            |
| 84  | Explain the concept of a class getter and setter in JavaScript.                                | Getters and setters define computed properties. Example: `javascript class MyClass { #value = 42; get val() { return this.#value; } set val(v) { this.#value = v; } } const obj = new MyClass(); console.log(obj.val); // 42 obj.val = 100; console.log(obj.val); // 100`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Edge cases: Missing setters make properties read-only. Infinite getter/setter recursion causes errors.                                                                                    |
| 85  | What is the difference between `Array.prototype.reverse` and a custom reverse?                 | `reverse` reverses the array in place. A custom reverse creates a new array. Example: `javascript const arr = [1, 2, 3]; arr.reverse(); // [3, 2, 1] const custom = [...arr].reverse(); // [1, 2, 3], arr stays [3, 2, 1]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Edge cases: `reverse` mutates the original. Sparse arrays may behave unexpectedly.                                                                                                        |
| 86  | How do you implement a memoized recursive function?                                            | Cache results in a closure or `Map`. Example: `javascript function memoize(fn) { const cache = new Map(); return function(n) { if (cache.has(n)) return cache.get(n); const result = fn(n, memoized); cache.set(n, result); return result; }; } const factorial = memoize((n, fn) => n === 0 ? 1 : n * fn(n - 1)); console.log(factorial(5)); // 120`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Edge cases: Cache growth can cause memory issues. Recursive calls must use the memoized function.                                                                                         |
| 87  | What is the purpose of `Array.prototype.groupBy`? Provide an example.                          | `groupBy` groups array elements by a key from a callback (proposed feature). Example: `javascript const arr = [1, 2, 3, 4]; const grouped = arr.groupBy(x => x % 2 ? 'odd' : 'even'); console.log(grouped); // { odd: [1, 3], even: [2, 4] }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Edge cases: Requires modern JavaScript support. Non-unique keys overwrite earlier values.                                                                                                 |
| 88  | Explain the concept of a Proxy trap for function application.                                  | The `apply` trap intercepts function calls. Example: `javascript const target = function() { return 'Called'; }; const proxy = new Proxy(target, { apply(target, thisArg, args) { return target(...args).toUpperCase(); } }); console.log(proxy()); // CALLED`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Edge cases: Incorrect `thisArg` binding can cause errors. Non-function targets throw errors.                                                                                              |
| 89  | What is the difference between `Array.prototype.pop` and `Array.prototype.shift`?              | `pop` removes and returns the last element. `shift` removes and returns the first element. Example: `javascript const arr = [1, 2, 3]; console.log(arr.pop()); // 3 console.log(arr.shift()); // 1`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Edge cases: Empty arrays return `undefined`. `shift` is slower for large arrays due to reindexing.                                                                                        |
| 90  | How do you implement a custom Promise.all implementation?                                      | Handle an array of Promises, resolving or rejecting based on their outcomes. Example: `javascript function myPromiseAll(promises) { return new Promise((resolve, reject) => { const results = []; let count = 0; promises.forEach((p, i) => { Promise.resolve(p).then(val => { results[i] = val; if (++count === promises.length) resolve(results); }).catch(reject); }); }); }`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Edge cases: Empty arrays resolve immediately. Non-Promise values are resolved automatically.                                                                                              |
| 91  | What is the purpose of `Array.prototype.toSorted`? Provide an example.                         | `toSorted` returns a new sorted array without mutating the original (proposed). Example: `javascript const arr = [3, 1, 2]; console.log(arr.toSorted((a, b) => a - b)); // [1, 2, 3] console.log(arr); // [3, 1, 2]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Edge cases: Requires modern JavaScript. Comparison function errors can cause issues.                                                                                                      |
| 92  | Explain the concept of a class inheritance in JavaScript.                                      | Classes use `extends` to inherit properties and methods. Example: `javascript class Animal { speak() { console.log('Sound'); } } class Dog extends Animal { speak() { console.log('Woof'); } } const dog = new Dog(); dog.speak(); // Woof`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Edge cases: Forgetting `super` in constructors causes errors. Prototype chain issues can arise with improper overrides.                                                                   |
| 93  | What is the difference between `Array.prototype.slice` and `Array.prototype.toSpliced`?        | `slice` returns a shallow copy of a portion. `toSpliced` returns a new array with elements removed/added (proposed). Example: `javascript const arr = [1, 2, 3, 4]; console.log(arr.slice(1, 3)); // [2, 3] console.log(arr.toSpliced(1, 2, 5)); // [1, 5, 4]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Edge cases: `toSpliced` requires modern JavaScript. Negative indices need careful handling.                                                                                               |
| 94  | How do you implement a custom Set implementation?                                              | Create a class with unique value storage. Example: `javascript class MySet { constructor() { this.items = []; } add(value) { if (!this.has(value)) this.items.push(value); return this; } has(value) { return this.items.includes(value); } } const set = new MySet(); set.add(1).add(2); console.log(set.has(1)); // true`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Edge cases: Object comparison checks references. Large sets impact performance.                                                                                                           |
| 95  | What is the purpose of `Array.prototype.with`? Provide an example.                             | `with` returns a new array with an element replaced at a specified index (proposed). Example: `javascript const arr = [1, 2, 3]; console.log(arr.with(1, 5)); // [1, 5, 3] console.log(arr); // [1, 2, 3]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Edge cases: Requires modern JavaScript. Invalid indices throw errors.                                                                                                                     |
| 96  | Explain the concept of a Proxy trap for property setting.                                      | The `set` trap intercepts property assignments. Example: `javascript const target = {}; const proxy = new Proxy(target, { set(target, prop, value) { console.log(`Setting ${prop} to ${value}`); target[prop] = value; return true; } }); proxy.a = 1; // Setting a to 1`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Edge cases: Returning `false` prevents assignment in strict mode. Non-writable properties cause errors.                                                                                   |
| 97  | What is the difference between `Array.prototype.findLast` and `Array.prototype.find`?          | `find` returns the first element matching the callback. `findLast` returns the last. Example: `javascript const arr = [1, 2, 3, 2]; console.log(arr.find(x => x === 2)); // 2 (first) console.log(arr.findLast(x => x === 2)); // 2 (last)`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Edge cases: `findLast` requires modern JavaScript. Returns `undefined` if no match.                                                                                                       |
| 98  | How do you implement a custom Map implementation?                                              | Create a class with key-value storage. Example: `javascript class MyMap { constructor() { this.items = []; } set(key, value) { const index = this.items.findIndex(([k]) => k === key); if (index !== -1) this.items[index][1] = value; else this.items.push([key, value]); } get(key) { const pair = this.items.find(([k]) => k === key); return pair ? pair[1] : undefined; } } const map = new MyMap(); map.set('a', 1); console.log(map.get('a')); // 1`                                                                                                                                                                                                                                                                                                                                                                                                      | Edge cases: Object keys check references. Large maps impact performance.                                                                                                                  |
| 99  | What is the purpose of `Array.prototype.toReversed`? Provide an example.                       | `toReversed` returns a new reversed array without mutating the original (proposed). Example: `javascript const arr = [1, 2, 3]; console.log(arr.toReversed()); // [3, 2, 1] console.log(arr); // [1, 2, 3]`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Edge cases: Requires modern JavaScript. Sparse arrays may skip empty slots.                                                                                                               |
| 100 | Explain the concept of a Proxy trap for property access.                                       | The `get` trap intercepts property reads. Example: ```javascript const target = { a: 1 }; const proxy = new Proxy(target, { get(target, prop) { return target[prop]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                           |
## ⚙️ JavaScript Deep Knowledge (25 Questions)

### 1. **What is a closure in JavaScript?**

**Answer:**

A closure is a function that retains access to its lexical scope even after the outer function has executed.

```
js
Copy code
function outer() {
  let count = 0;
  return function inner() {
    return ++count;
  };
}
const counter = outer();
counter(); // 1
counter(); // 2

```

---

### 2. **Explain prototypal inheritance.**

**Answer:**

Objects can inherit from other objects. In JS, every object has a prototype and delegates property access to it.

```
js
Copy code
const parent = { greet() { return "hi"; } };
const child = Object.create(parent);
child.greet(); // hi

```

---

### 3. **What are WeakMaps and WeakSets used for?**

**Answer:**

They store object keys without preventing garbage collection. Great for private data or caching.

```
js
Copy code
const wm = new WeakMap();
wm.set(obj, 'secret');

```

---

### 4. **Explain event loop and microtasks vs macrotasks.**

**Answer:**

Microtasks (like `Promise.then`) are prioritized over macrotasks (like `setTimeout`).

```
js
Copy code
Promise.resolve().then(() => console.log("micro"));
setTimeout(() => console.log("macro"), 0);
// Output: "micro", "macro"

```

---

### 5. **How does hoisting work in JS?**

**Answer:**

Variables declared with `var` are hoisted and initialized as `undefined`. `let`/`const` are hoisted but uninitialized (TDZ).

---

### 6. **What is currying?**

**Answer:**

Breaking a function into multiple unary functions.

```
js
Copy code
const multiply = a => b => a * b;
multiply(2)(3); // 6

```

---

### 7. **What is memoization and how is it implemented?**

**Answer:**

Caching the results of expensive function calls.

```
js
Copy code
function memo(fn) {
  const cache = {};
  return (...args) => {
    const key = args.join(',');
    if (key in cache) return cache[key];
    return (cache[key] = fn(...args));
  };
}

```

---

### 8. **Difference between deep and shallow copy?**

**Answer:**

Shallow copies reference nested objects; deep copies clone everything.

```
js
Copy code
JSON.parse(JSON.stringify(obj)); // deep
Object.assign({}, obj); // shallow

```

---

### 9. **What is the module pattern in JS?**

**Answer:**

Encapsulates private/public members using closures.

```
js
Copy code
const Counter = (function () {
  let count = 0;
  return {
    inc: () => ++count,
    get: () => count
  };
})();

```

---

### 10. **Difference between `bind`, `call`, and `apply`?**

**Answer:**

- `bind`: returns a new function
- `call`: invokes with args
- `apply`: like `call` but args as array

---

### 11. **Explain the Observer pattern in JS.**

**Answer:**

Objects subscribe to events from a subject.

```
js
Copy code
class Subject {
  observers = [];
  subscribe(fn) { this.observers.push(fn); }
  notify(data) { this.observers.forEach(fn => fn(data)); }
}

```

---

### 12. **Explain the Singleton pattern in JS.**

**Answer:**

Ensures only one instance.

```
js
Copy code
const singleton = (() => {
  let instance;
  return {
    getInstance: () => instance ??= {}
  };
})();

```

---

### 13. **What is tail call optimization?**

**Answer:**

A recursive call is the last operation and allows stack reuse (not supported in most JS engines yet).

---

### 14. **Difference between `undefined` and `null`?**

**Answer:**

- `undefined`: variable declared but not assigned
- `null`: intentional absence of value

---

### 15. **What are generators and how do they differ from normal functions?**

**Answer:**

Generators can pause execution and resume later.

```
js
Copy code
function* gen() {
  yield 1;
  yield 2;
}

```

---

### 16. **What is the difference between `Object.freeze()` and `Object.seal()`?**

**Answer:**

- `freeze`: no add/remove/change
- `seal`: no add/remove, but can change

---

### 17. **What is a debounce vs throttle function?**

**Answer:**

- Debounce: wait until no calls for X ms
- Throttle: call at most once every X ms

---

### 18. **Explain composition vs inheritance.**

**Answer:**

Composition = “has a” (preferred), Inheritance = “is a”

JS favors composition via functions and modules.

---

### 19. **What is the difference between strict mode and non-strict?**

**Answer:**

Strict mode prevents silent errors and disallows bad syntax like implicit globals.

`'use strict';`

---

### 20. **What is a Service Worker?**

**Answer:**

A JS file that intercepts network requests, supports offline caching, push notifications.

---

### 21. **Explain Event Delegation.**

**Answer:**

Listening to events on a parent and using `event.target` to act on children.

---

### 22. **Difference between `async/await` and `.then()`?**

**Answer:**

`async/await` is syntactic sugar over promises. More readable and linear.

---

### 23. **What is the Revealing Module Pattern?**

**Answer:**

Expose public members by returning an object from a closure.

---

### 24. **Explain the Factory pattern.**

**Answer:**

Creates objects without exposing instantiation logic.

```
js
Copy code
function userFactory(role) {
  return {
    role,
    permissions: () => role === "admin" ? "all" : "read"
  };
}

```
### 25. **Explain immutability in JS.**

**Answer:**

Avoid modifying existing data — use spread, `map`, etc.